// Generated by gencpp from file moobot_msgs/bms_status.msg
// DO NOT EDIT!


#ifndef MOOBOT_MSGS_MESSAGE_BMS_STATUS_H
#define MOOBOT_MSGS_MESSAGE_BMS_STATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace moobot_msgs
{
template <class ContainerAllocator>
struct bms_status_
{
  typedef bms_status_<ContainerAllocator> Type;

  bms_status_()
    : battery_voltage(0.0)
    , load_voltage(0.0)
    , charger_voltage(0.0)
    , cell_voltage()
    , temperature_bms(0.0)
    , temperature_cell()
    , current_income(0.0)
    , capacity(0.0)
    , capacity_max(0.0)
    , soc(0.0)
    , current_charger(0.0)
    , current_load(0.0)  {
    }
  bms_status_(const ContainerAllocator& _alloc)
    : battery_voltage(0.0)
    , load_voltage(0.0)
    , charger_voltage(0.0)
    , cell_voltage(_alloc)
    , temperature_bms(0.0)
    , temperature_cell(_alloc)
    , current_income(0.0)
    , capacity(0.0)
    , capacity_max(0.0)
    , soc(0.0)
    , current_charger(0.0)
    , current_load(0.0)  {
  (void)_alloc;
    }



   typedef float _battery_voltage_type;
  _battery_voltage_type battery_voltage;

   typedef float _load_voltage_type;
  _load_voltage_type load_voltage;

   typedef float _charger_voltage_type;
  _charger_voltage_type charger_voltage;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _cell_voltage_type;
  _cell_voltage_type cell_voltage;

   typedef float _temperature_bms_type;
  _temperature_bms_type temperature_bms;

   typedef std::vector<float, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<float>> _temperature_cell_type;
  _temperature_cell_type temperature_cell;

   typedef float _current_income_type;
  _current_income_type current_income;

   typedef float _capacity_type;
  _capacity_type capacity;

   typedef float _capacity_max_type;
  _capacity_max_type capacity_max;

   typedef float _soc_type;
  _soc_type soc;

   typedef float _current_charger_type;
  _current_charger_type current_charger;

   typedef float _current_load_type;
  _current_load_type current_load;





  typedef boost::shared_ptr< ::moobot_msgs::bms_status_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::moobot_msgs::bms_status_<ContainerAllocator> const> ConstPtr;

}; // struct bms_status_

typedef ::moobot_msgs::bms_status_<std::allocator<void> > bms_status;

typedef boost::shared_ptr< ::moobot_msgs::bms_status > bms_statusPtr;
typedef boost::shared_ptr< ::moobot_msgs::bms_status const> bms_statusConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::moobot_msgs::bms_status_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::moobot_msgs::bms_status_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::moobot_msgs::bms_status_<ContainerAllocator1> & lhs, const ::moobot_msgs::bms_status_<ContainerAllocator2> & rhs)
{
  return lhs.battery_voltage == rhs.battery_voltage &&
    lhs.load_voltage == rhs.load_voltage &&
    lhs.charger_voltage == rhs.charger_voltage &&
    lhs.cell_voltage == rhs.cell_voltage &&
    lhs.temperature_bms == rhs.temperature_bms &&
    lhs.temperature_cell == rhs.temperature_cell &&
    lhs.current_income == rhs.current_income &&
    lhs.capacity == rhs.capacity &&
    lhs.capacity_max == rhs.capacity_max &&
    lhs.soc == rhs.soc &&
    lhs.current_charger == rhs.current_charger &&
    lhs.current_load == rhs.current_load;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::moobot_msgs::bms_status_<ContainerAllocator1> & lhs, const ::moobot_msgs::bms_status_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace moobot_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::moobot_msgs::bms_status_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::moobot_msgs::bms_status_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::moobot_msgs::bms_status_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::moobot_msgs::bms_status_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::moobot_msgs::bms_status_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::moobot_msgs::bms_status_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::moobot_msgs::bms_status_<ContainerAllocator> >
{
  static const char* value()
  {
    return "08c0d01e45dd995f3adfffdf7aa31d50";
  }

  static const char* value(const ::moobot_msgs::bms_status_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x08c0d01e45dd995fULL;
  static const uint64_t static_value2 = 0x3adfffdf7aa31d50ULL;
};

template<class ContainerAllocator>
struct DataType< ::moobot_msgs::bms_status_<ContainerAllocator> >
{
  static const char* value()
  {
    return "moobot_msgs/bms_status";
  }

  static const char* value(const ::moobot_msgs::bms_status_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::moobot_msgs::bms_status_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 battery_voltage  # Voltage in Volts \n"
"float32 load_voltage  # Voltage in Volts \n"
"float32 charger_voltage  # Voltage in Volts \n"
"float32[] cell_voltage   # An array of individual cell voltages for each cell in the pack\n"
"\n"
"float32 temperature_bms      # Temperature in Degrees Celsius (If unmeasured NaN)\n"
"float32[] temperature_cell  # An array of individual cell temperatures for each cell in the pack\n"
"\n"
"float32 current_income     # Pile gelen akım      \n"
"float32 capacity           # Pilin doluluk kapasitesi -> Capacity in Ah (last full capacity) \n"
"float32 capacity_max  	    # Pilin total kapasitesi -> Capacity in Ah (design capacity)  \n"
"float32 soc                # Charge percentage on 0 to 1 range -> percentage\n"
"float32 current_charger    # A     \n"
"float32 current_load       # Sistemin Çektiği Akım -> Negative when discharging (A)  \n"
"\n"
"#float32 battery_volt_1\n"
"#float32 battery_volt_2\n"
"#float32 battery_volt_total\n"
"#float32 battery_temp_1\n"
"#float32 battery_temp_2\n"
"#float32 current_main\n"
"#float32 total_power_wh\n"
"\n"
;
  }

  static const char* value(const ::moobot_msgs::bms_status_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::moobot_msgs::bms_status_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.battery_voltage);
      stream.next(m.load_voltage);
      stream.next(m.charger_voltage);
      stream.next(m.cell_voltage);
      stream.next(m.temperature_bms);
      stream.next(m.temperature_cell);
      stream.next(m.current_income);
      stream.next(m.capacity);
      stream.next(m.capacity_max);
      stream.next(m.soc);
      stream.next(m.current_charger);
      stream.next(m.current_load);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct bms_status_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::moobot_msgs::bms_status_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::moobot_msgs::bms_status_<ContainerAllocator>& v)
  {
    s << indent << "battery_voltage: ";
    Printer<float>::stream(s, indent + "  ", v.battery_voltage);
    s << indent << "load_voltage: ";
    Printer<float>::stream(s, indent + "  ", v.load_voltage);
    s << indent << "charger_voltage: ";
    Printer<float>::stream(s, indent + "  ", v.charger_voltage);
    s << indent << "cell_voltage[]" << std::endl;
    for (size_t i = 0; i < v.cell_voltage.size(); ++i)
    {
      s << indent << "  cell_voltage[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.cell_voltage[i]);
    }
    s << indent << "temperature_bms: ";
    Printer<float>::stream(s, indent + "  ", v.temperature_bms);
    s << indent << "temperature_cell[]" << std::endl;
    for (size_t i = 0; i < v.temperature_cell.size(); ++i)
    {
      s << indent << "  temperature_cell[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.temperature_cell[i]);
    }
    s << indent << "current_income: ";
    Printer<float>::stream(s, indent + "  ", v.current_income);
    s << indent << "capacity: ";
    Printer<float>::stream(s, indent + "  ", v.capacity);
    s << indent << "capacity_max: ";
    Printer<float>::stream(s, indent + "  ", v.capacity_max);
    s << indent << "soc: ";
    Printer<float>::stream(s, indent + "  ", v.soc);
    s << indent << "current_charger: ";
    Printer<float>::stream(s, indent + "  ", v.current_charger);
    s << indent << "current_load: ";
    Printer<float>::stream(s, indent + "  ", v.current_load);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MOOBOT_MSGS_MESSAGE_BMS_STATUS_H
